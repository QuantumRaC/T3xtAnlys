# This is a custom security layer middleware that enforces Message Integrity
# and Anti-Replay protection for all sensitive API endpoints. It intercepts 
# incoming HTTP requests before they reach the route handlers, verifying 
# that the request was generated by a trusted client and has not been 
# tampered with during transit. 

# It uses HMAC-SHA256 hashing
# and a 300 seconds time window to prevent replay attacks. 
# The key is stored as an environment variable.

# FastAPI is built on top of the Starlette framework, and creating 
# custom middleware would mean to inherit from BaseHTTPMiddleware.

# https://fastapi.tiangolo.com/tutorial/middleware/


import hmac
import hashlib
import time
import os
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import JSONResponse
from starlette.types import Message

class RSignatureMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        secret_key = os.getenv("RSEC_SECRET_KEY") # load from environment variable
        if not secret_key:
             return JSONResponse(
                 status_code=500, 
                 content={"error": "Server configuration error (Missing rSec Signature Secret)"})
        # We cannot call response = await call_next(request) because then it goes to the route handler first
        # and we want to verify the request BEFORE it reaches the route handler. 
        # (call_next essentially means calling the next middleware in line or the actual route handler).
        # We will call it at the end after verification.

        # 1. Exclude "safe" paths so the middleware doesn't block itself
        safe_paths = ["/docs", "/openapi.json", "/redoc"]
        if request.url.path in safe_paths:
            return await call_next(request)
        
        # 2. Get headers
        # In our CORS middleware we need to expose them so client in a browser can see those custom headers
        rSec_Timestamp = request.headers.get("X-rSec-Timestamp") # time of the request
        rSec_Signature = request.headers.get("X-rSec-Signature") 
        if not rSec_Timestamp or not rSec_Signature:
            return JSONResponse(status_code=400, content={"error": "Missing Security Headers"})

        # 3. Replay protection
        current_time = time.time()
        time_window_allowed = 300 # Allowed time window setting to prevent replay attacks
        try:
            # Check for Replay Attack (Drift)
            if abs(current_time - int(rSec_Timestamp)) > time_window_allowed:
                return JSONResponse(status_code=403, content={"error": "Request expired."})
        except ValueError:
            return JSONResponse(status_code=400, content={"error": "Invalid Timestamp Format"})
        
        # 4. Handle body consumption
        body_bytes = await request.body()
        # Create a new receive function for the downstream request
        async def receive() -> Message:
            return {"type": "http.request", "body": body_bytes, "more_body": False}
        # Create a new Request object with the same scope and the new receive function
        request = Request(request.scope, receive)

        # 5. Reconstruct the signature
        user_id = request.headers.get("x-user-id")
        if not user_id:
            return JSONResponse(status_code=400, content={"error": "Missing x-user-id header"})
        method = request.method
        path = request.url.path
        body_str = body_bytes.decode()

        message = f"{user_id}.{rSec_Timestamp}.{method}.{path}.{body_str}"
        reconstructed_signature = hmac.new(
            secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()

        # 6. Compare the signatures with hmac.compare_digest
        if not hmac.compare_digest(rSec_Signature, reconstructed_signature):
            return JSONResponse(
                status_code=403,
                content={"error": "Invalid signature."}
            )
        
        # 7. Putting the reconstructed signature back into the request
        response = await call_next(request)
        response.headers["X-rSec-Timestamp"] = str(current_time) # HTTP header must be str
        response.headers["X-rSec-Signature"] = reconstructed_signature
        
        # 8. Pass response
        return response